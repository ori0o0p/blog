<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.3.4">Jekyll</generator><link href="http://localhost:4000/blog/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/blog/" rel="alternate" type="text/html" /><updated>2025-05-19T22:07:27+09:00</updated><id>http://localhost:4000/blog/feed.xml</id><title type="html">Seungwon</title><subtitle>개발 블로그</subtitle><entry><title type="html">PECS</title><link href="http://localhost:4000/blog/language/pecs/" rel="alternate" type="text/html" title="PECS" /><published>2024-07-28T00:00:00+09:00</published><updated>2024-07-28T00:00:00+09:00</updated><id>http://localhost:4000/blog/language/pecs</id><content type="html" xml:base="http://localhost:4000/blog/language/pecs/"><![CDATA[<p><strong>Producer Extends Consumer Super</strong></p>

<h2 id="pecs-원칙">PECS 원칙</h2>
<ul>
  <li>Producer: 데이터를 생산하는 객체</li>
  <li>Consumer: 데이터를 소비하는 객체</li>
</ul>

<h3 id="원칙">원칙</h3>

<ul>
  <li>Producer <strong><code class="language-plaintext highlighter-rouge">Extends</code></strong>: 데이터를 읽을 때는 extends 와일드카드를 사용 &lt;? extends T&gt;</li>
  <li>
    <p>Consumer <strong><code class="language-plaintext highlighter-rouge">Super</code></strong>: 데이터를 쓸 때는 super 와일드카드를 사용 &lt;? super T&gt;</p>
  </li>
  <li>&lt;? extends T&gt;: T 타입이나 T의 하위 타입만 허용 (읽기 전용)</li>
  <li>&lt;? super T&gt;: T 타입이나 T의 상위 타입만 허용 (쓰기 가능)</li>
</ul>

<h3 id="예시">예시</h3>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Producer (읽기)</span>
<span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="nc">Number</span> <span class="n">n</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">get</span><span class="o">(</span><span class="mi">0</span><span class="o">);</span>  

<span class="c1">// Consumer (쓰기)</span>
<span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
<span class="n">integers</span><span class="o">.</span><span class="na">add</span><span class="o">(</span><span class="mi">10</span><span class="o">);</span> 
</code></pre></div></div>

<ul>
  <li>extends: 요소 추가 불가, 읽기만 가능</li>
  <li>super: 요소 읽을 때 Object 타입으로만 가능</li>
</ul>

<p>왜 extends에서 쓰기는 불가능한가에 대해 더 살펴보겠다</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">extends</span> <span class="nc">Number</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<p>이 경우에 numbers 리스트는 Number의 어떤 하위 타입이든 포함할 수 있따. <code class="language-plaintext highlighter-rouge">&lt;? extends Number&gt;</code> 이므로.</p>

<p>근데? 컴파일러 입장에선 정확히 어떤 하위 타입인지 모른다. Integer인지 Double인지 ?</p>

<p>타입을 모르니 <code class="language-plaintext highlighter-rouge">numbers.add(new Integer(10))</code>을 허용하면</p>

<p>리스트가 <code class="language-plaintext highlighter-rouge">ArrayList&lt;Double&gt;</code>일 경우 타입 안전성이 깨진다.</p>

<p>이런 이유로 쓰기가 불가능한 것이다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">List</span><span class="o">&lt;?</span> <span class="kd">super</span> <span class="nc">Integer</span><span class="o">&gt;</span> <span class="n">integers</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ArrayList</span><span class="o">&lt;&gt;();</span>
</code></pre></div></div>

<p>이 경우를 살펴보겠디.</p>

<p>integers 리스트는 Integer의 어떤 상위 타입이든 될 수 있다.</p>

<p>뭐 Number일 수도, Object일 수도 있다.</p>

<p>컴파일러는 정확한 타입을 모르니 가장 상위 타입인 Object로 읽을 수 있다.</p>

<p>근데 왜 쓰기가 가능할까?
당연한 것이다. Integer 타입이 Number든, Object든 상위 타입에 안전하게 들어갈 수 있으니 쓰기가 가능하다.</p>]]></content><author><name></name></author><category term="language" /><category term="Java" /><category term="Generic" /><category term="PECS" /><summary type="html"><![CDATA[Producer Extends Consumer Super]]></summary></entry><entry><title type="html">Java Throwing Exception</title><link href="http://localhost:4000/blog/language/java-throwing-exception/" rel="alternate" type="text/html" title="Java Throwing Exception" /><published>2024-06-17T00:00:00+09:00</published><updated>2024-06-17T00:00:00+09:00</updated><id>http://localhost:4000/blog/language/java-throwing-exception</id><content type="html" xml:base="http://localhost:4000/blog/language/java-throwing-exception/"><![CDATA[<p>자바를 넘어서 모든 SW의 예외 처리는 매우 중요하다. 
이를 통해 개발자는 예상치 못한 오류를 적절하게 해결할 수 있어 해당 SW의 품질을 보장할 수 있는 그런 작업이다.</p>

<p>자바 프로그래밍 내에서의 예외 처리를 이해해보자.</p>

<h2 id="exception이란">Exception이란?</h2>

<p>자바 프로그래밍 내에서의 예외는 런타임 환경에서 발생하여, 프로그램이 정상적인 진행을 하지 못하게 하는 사건 즉 시스템은 올바르게 이루어져 있지만, 개발자의 로직의 오류를 말한다. 
보통 0으로 나누기, null인 객체에 접근, 존재하지 않는 파일에 접근 등의 예외 상황이 있다.</p>

<h2 id="throw-statement">Throw statement</h2>
<p>자바를 사용해 개발 또는 학습을 진행하였다면, throw, throws 등의 구문. 키워드를 본 적이 있을 것이다.</p>

<p>예를 들면 이런 식이다.</p>
<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">method1</span><span class="o">()</span> <span class="kd">throws</span> <span class="nc">InterruptedException</span> <span class="o">{</span>
		<span class="nc">Thread</span><span class="o">.</span><span class="na">sleep</span><span class="o">(</span><span class="mi">5000L</span><span class="o">);</span>
		
		<span class="k">throw</span> <span class="k">new</span> <span class="nf">RuntimeException</span><span class="o">();</span>
<span class="o">}</span> <span class="c1">// 극단적인 예시.</span>
</code></pre></div></div>
<p>이 파트에선 throw. 메서드 바디 내에서 예외를 발생. 혹은 던지는 것을 학습할 것이다.</p>

<p>자바에서 throw 구문을 사용해 예외를 발생시키는 것은 간단하다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">throw</span> <span class="nc">ThrowableObject</span><span class="o">;</span> 
</code></pre></div></div>

<p>ThrowableObject은 자바의 모든 예외에 대한 기본 클래스인 Throwable를 확장하는 클래스의 인스턴스이어야 한다.</p>

<p>뭐 예를 들면 많이들 알고 있는 RuntimeException이라던가 예외들이 throw 구문 뒤에 위치할 수 있다.</p>

<h2 id="checked-unchecked-exception"><strong>Checked.’ Unchecked Exception</strong></h2>

<p>Checked Exception은 개발자가 무조건 처리해야하는 컴파일 시점에서 발생하는 오류이다.</p>

<p>예로 들자면. Thread.sleep 메서드를 사용하고 싶을 때 일반 적인 메서드 블록에 작성하면 빨간 줄이 생기는 모습을 본 적이 있을 것이다.</p>

<p>해당 에러를 확인하면. Unhandled exception: ..InterruptedException을 확인 할 수 있는데.</p>

<p>InterruptedException를 핸들링 해줘야한다고 한다. 왜 그럴까?</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">sleep</span><span class="o">(</span><span class="kt">long</span> <span class="n">millis</span><span class="o">)</span> <span class="o">**</span><span class="kd">throws</span> <span class="nc">InterruptedException</span><span class="o">**</span> <span class="o">{</span>
    <span class="o">...</span>
<span class="o">}</span>
</code></pre></div></div>

<p>sleep 메서드의 구현을 보니 <strong>throws InterruptedException</strong>이 작성되어 있는 걸 볼 수 있다.</p>

<p>아! throws는 전염되는 구나! 그렇다. .</p>

<p>throws를 사용한 건 메서드 블록이 해당 예외를 발생시킬 수 있다고 작성한 것이고,</p>

<p>왜 명시를 해야하는 걸까?
InterruptedException은 checked exception으로 외부의 리소스, 서비스와 상호작용해야할 때 잠재적인 예외 상황을 기호화해서 예측할 수 없게 실패할 수 있는 오류 처리를 해야하기 때문이다.</p>

<p>Unchecked Exception은 개발자의 예외 처리가 필수가 아니고, 런타임 시점에서 발생할 수 있는 예외이다.</p>

<p>주로 코드의 결함이나, 논리적 문제에서 발생한다.</p>

<p>예를 들면</p>

<ul>
  <li>유효한 범위가 아닌 배열 인덱스에 접근하였을 때 (ArrayIndexOutOfBoundsException)</li>
  <li>null인 객체에 접근을 했을 때 (NullPointerException)</li>
</ul>

<p>발생하는 예외이다.</p>

<h2 id="spring-controlleradvice">Spring ControllerAdvice</h2>

<p>ControllerAdvice 어노테이션을 자세히 알아보지는 않을 것이다.</p>

<p>그저 독자들이 주로 스프링 부트를 사용해 애플리케이션을 개발하고 있을텐데, 전역적으로 예외를 잡아주는 ControllerAdvice를 사용할 거라 생각했다.</p>

<p>그렇다면 본인은 Custom Exception을 직접 비즈니스에 맞게 작성하여 사용하고 있는가?</p>

<h2 id="정말-잘-사용하고-있을까">정말 잘 사용하고 있을까?</h2>

<p>비즈니스 로직이 커지면 예외 상황은 더 늘어날 수 밖에 없다. 하지만 예외 처리를 할 때 생기는 비용을 생각해본 적이 있나?</p>

<p>예외 생성 비용은 비싸다. 예외 발생 회수가 커질 수록 문제가 생길 수도 있다.</p>

<p>예외 생성 비용에 가장 영향을 미치는 요소는 trace로 예외 발생 경로이다.</p>

<p>이를 해결하기 위해 stack trace를 갖지 않도록 설정할 수 있는데,</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nd">@Override</span>
<span class="kd">public</span> <span class="kd">synchronized</span> <span class="nc">Throwable</span> <span class="nf">fillInStackTrace</span><span class="o">()</span> <span class="o">{</span>
  <span class="k">return</span> <span class="k">this</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>위와 같이 fillInStackTrace 메서드를 아무 stack trace를 갖지 않도록 override할 수 있다.</p>

<p>또 위와 같이 생성했다면 static final 필드에 미리 예외를 캐싱해두고 사용하면 비용을 더 줄일 수 있을 것이다.</p>]]></content><author><name></name></author><category term="language" /><category term="Java" /><category term="Exception" /><category term="Exception Handling" /><summary type="html"><![CDATA[자바를 넘어서 모든 SW의 예외 처리는 매우 중요하다. 이를 통해 개발자는 예상치 못한 오류를 적절하게 해결할 수 있어 해당 SW의 품질을 보장할 수 있는 그런 작업이다.]]></summary></entry><entry><title type="html">Reference Type</title><link href="http://localhost:4000/blog/language/reference-type/" rel="alternate" type="text/html" title="Reference Type" /><published>2024-05-26T00:00:00+09:00</published><updated>2024-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/language/reference-type</id><content type="html" xml:base="http://localhost:4000/blog/language/reference-type/"><![CDATA[<p>프로그램이 객체 생명 주기를 효과적으로 관리할 수 있는 객체 참조 유형 4가지를 정리합니다</p>

<h2 id="strong">Strong</h2>

<p>강한 참조 타입. 가장 일반적으로 사용되는 참조 타입이다.</p>

<ul>
  <li>해당 Strong 참조가 있는 객체는 GC의 대상이 되지 않는다.</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">Object</span> <span class="n">strongReference</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
</code></pre></div></div>

<p>메모리 공간이 부족하다 해도, 회수를 하지 않는다.</p>

<p>GC의 대상이 되게 하려면</p>

<ul>
  <li>참조 X</li>
</ul>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">void</span> <span class="nf">test</span><span class="o">()</span> <span class="o">{</span>
    <span class="nc">Object</span> <span class="n">strongReference</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Object</span><span class="o">();</span>
<span class="o">}</span>
</code></pre></div></div>

<p>해당 메서드 블록이 실행되고 메서드 스택이 종료된다면, 참조된 객체가 0이므로 해당 객체는 재활용될 것이다.</p>

<p>하지만 이 내용은 지역 변수에만 해당하는 내용이라 인스턴스 변수의 Strong 참조일 경우 GC의 대상이 되게하려면 <code class="language-plaintext highlighter-rouge">strongReference</code>객체를 null로 설정하는 방법이 있다.</p>

<h2 id="soft">Soft</h2>

<p>소프트 참조만 있는 경우 GC는 메모리 공간이 충분할 때엔 해당 객체를 회수하지 않는다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// Strong reference</span>
<span class="nc">String</span> <span class="n">strongReference</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="c1">// Soft references</span>
<span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="nc">SoftReference</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">softReference</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">SoftReference</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;(</span><span class="n">str</span><span class="o">);</span>
</code></pre></div></div>

<p>JVM 메모리가 부족할 때 소프트 참조 개체는 회수된다.</p>

<p>메모리가 부족하면 JVM은 먼저 해당 객체 참조를 null로 설정 후 GC의 대상이 되도록 한다.</p>

<p>탐색한 웹 페이지를 찾거나 뒤로 가기를 할 때 사용될 수 있다.</p>

<h2 id="weak">Weak</h2>

<p>약한 참조만 있는 객체가 발견되면 현재 메모리 공간이 충분한지 여부에 관계없이 해당 객체의 메모리가 회수한다.</p>

<p>하지만, GC는 스레드 우선순위가 낮아 해당 객체를 빨리 찾지 못할 수 있다.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="nc">WeakReference</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">weakReference</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WeakReference</span><span class="o">&lt;&gt;(</span><span class="n">str</span><span class="o">);</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nc">String</span> <span class="n">str</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">String</span><span class="o">(</span><span class="s">"abc"</span><span class="o">);</span>
<span class="nc">WeakReference</span><span class="o">&lt;</span><span class="nc">String</span><span class="o">&gt;</span> <span class="n">weakReference</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">WeakReference</span><span class="o">&lt;&gt;(</span><span class="n">str</span><span class="o">);</span>
<span class="nc">String</span> <span class="n">strongReference</span> <span class="o">=</span> <span class="n">weakReference</span><span class="o">.</span><span class="na">get</span><span class="o">();</span>
</code></pre></div></div>

<p>위와 같이 약한 객체를 강한 객체로 변경할 수 있다.</p>

<h2 id="phantom">Phantom</h2>

<p>쓸모가 없다.</p>

<p>해당 참조는 객체의 생명 주기를 결정하지 않는다.</p>

<p>→ GC가 해당 객체를 보기에 참조가 없는 것 처럼 보인다.</p>]]></content><author><name></name></author><category term="language" /><category term="Java" /><category term="Reference Type" /><summary type="html"><![CDATA[프로그램이 객체 생명 주기를 효과적으로 관리할 수 있는 객체 참조 유형 4가지를 정리합니다]]></summary></entry><entry><title type="html">Scoped Values</title><link href="http://localhost:4000/blog/language/scoped-values/" rel="alternate" type="text/html" title="Scoped Values" /><published>2024-05-26T00:00:00+09:00</published><updated>2024-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/language/scoped-values</id><content type="html" xml:base="http://localhost:4000/blog/language/scoped-values/"><![CDATA[<p>특정 스레드 또는 작업으로 제한되는 범위 값을 생성할 수 있는 기능이다.</p>

<p>스레드 로컬 변수와 비슷하지만, 
이 범위 값은 virtual threads, structured concurrency와 함께 작동되도록 설계되었다.</p>

<p>복잡한 동기화나 잠금 메커니즘 없이 구조화된 방식으로 작업과 가상 스레드 간에 값을 전달 가능하고,</p>

<p>스레드 로컬 변수와 달리 범위 값은 한 번 작성되며 스레드 실행 중 제한된 기간 동안만 사용할 수 있다
<code class="language-plaintext highlighter-rouge">ScopedValue&lt;&gt;</code></p>]]></content><author><name></name></author><category term="language" /><category term="Java" /><category term="Java 21" /><category term="Scoped Values" /><summary type="html"><![CDATA[특정 스레드 또는 작업으로 제한되는 범위 값을 생성할 수 있는 기능이다.]]></summary></entry><entry><title type="html">Coroutines</title><link href="http://localhost:4000/blog/language/kotlin-coroutines/" rel="alternate" type="text/html" title="Coroutines" /><published>2024-05-26T00:00:00+09:00</published><updated>2024-05-26T00:00:00+09:00</updated><id>http://localhost:4000/blog/language/kotlin-coroutines</id><content type="html" xml:base="http://localhost:4000/blog/language/kotlin-coroutines/"><![CDATA[<p>코틀린 진영에서의 자바 가상 스레드와 같은 경량 동시성 모델</p>

<h2 id="왜-코루틴을-사용해야-하는가">왜 코루틴을 사용해야 하는가?</h2>

<p>코틀린에서 비동기 프로그래밍을 하기 위해?(맞음)</p>

<p>비동기식 코드를 동기 방식으로 작성하기 위해(맞음) ⇒ 콜백지옥이 이제 없음(행복?)</p>

<ul>
  <li>코틀린 코루틴에선 콜백 스타일의 코드가 아닌 명령형 프로그래밍 스타일임.</li>
</ul>

<p>코루틴도 가상 스레드 처럼 OS 스레드에 직접 매핑되지 않고 <em>continuations</em>이라는 객체를 사용해 ULT에서 매핑이 이루어진다. (경량 스레드)</p>

<p>⇒ 코루틴 간 전환(CS)에서는 OS가 다른 스레드의 컨텍스트를 로드할 필요가 없지만 참조를 <em>continuations</em> 객체로 전환해야한다.</p>

<h2 id="비동기라면서-왜-반응형-프로그래밍을-안-함">비동기라면서 왜 반응형 프로그래밍을 안 함?</h2>

<p>반응형 프로그래밍에서의 코드를 작성하고 유지하려면 더욱 비용이 커지고, 복잡해진다.</p>

<ul>
  <li>대부분 FP 스타일로 작성되어 처음엔 보기 쉽겠지만, <code class="language-plaintext highlighter-rouge">subscribeOn</code>과 같이 실행 흐름을 다른 스레드로 넘겨 버리는 함수가 존재해 실행 흐름을 판단하기 어려울 것이고, 다 다른 스레드에서 작동된다면 당연히 예외 추적도 힘들 것이다.</li>
</ul>

<h2 id="suspend-키워드">Suspend 키워드?</h2>

<p>suspend 키워드는 코루틴에서 빠지면 안되는 기능이다.</p>

<p>해당 키워드를 메서드(함수)에 붙이게 된다면 해당 함수는 코루틴이라고 명시를 해줄 수 있고, 일시 중지를 할 수 있는 메서드라고 표시를 한다.</p>

<p>⇒ 일시 중지하고 언젠간? 재시작</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuIsComing</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주가 오고 있어요!"</span><span class="p">)</span> <span class="c1">// 함수 시작 point</span>
  <span class="nf">delay</span><span class="p">(</span><span class="mi">500L</span><span class="p">)</span> <span class="c1">// delay(timeMillis: Long) // 함수 중단 point</span>
  <span class="n">logger</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주가 도착했어요!"</span><span class="p">)</span> <span class="c1">// 함수 재개 point</span>
<span class="p">}</span>
</code></pre></div></div>

<p>minjuIsComing 코루틴이 실행될 때 delay 기능에서 일시 중지하고, 다시 재개를 한다.</p>

<p>해당 메커니즘을 자세히 소개 해주겟다</p>

<p>suspending 된 함수는 전체 문맥(context)가 <code class="language-plaintext highlighter-rouge">Continuation&lt;T&gt;</code>에 저장된다. 
Continuation 객체에는 함수의 변수 및 매개변수의 모든 상태, 실행이 중단된 지점(<strong>label</strong>)이 저장이 된다.</p>

<p>코틀린 컴파일러는 중지된 함수를 아래와 같이 재구성? 한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuIsComing</span><span class="p">()</span>

<span class="k">fun</span> <span class="nf">minjuIsComing</span><span class="p">(</span><span class="n">continuation</span><span class="p">:</span> <span class="nc">Continuation</span><span class="p">&lt;</span><span class="err">*</span><span class="p">&gt;):</span> <span class="nc">Any</span> 
</code></pre></div></div>

<p>? 컴파일러 녀석이 왜 변환 값까지 바꾸나요.</p>

<p><code class="language-plaintext highlighter-rouge">suspend</code>함수가 일시 중지되면 함수 값을 반환할 수 없다.</p>

<p>하지만, 함수가 일시 중지되었음을 표시하는 값(<code class="language-plaintext highlighter-rouge">COROUTINE_SUSPENDED</code>)을 반환해야하기 때문에 반환 값이 바뀌는 것이다.</p>

<p>파라미터로 받는 continuation 객체에 해당 함수의 정보를 저장하기 위해 래핑을 한 번한다.</p>

<p>래핑을 해 생긴 continuation 객체의 이름은 <code class="language-plaintext highlighter-rouge">MinjuIsComingContinuation</code>이다.</p>

<ul>
  <li><em>**</em>정지 함수를 호출할 때마다 continuation 객체를 새 함수로 래핑을 한다.</li>
</ul>

<p>실행 정보를 저장하는 필드 label은 해당 함수가 처음 시작되면 0이고, 만약 0이라면 중단 함수를 만날 때까지 실행하다가 중단 함수(delay)를 만나 label은 1이 되고, 중단 함수를 실행 시키게 된다.</p>

<p>delay 함수가 <code class="language-plaintext highlighter-rouge">COROUTINE_SUSPENDED</code>를 반환하게 되면 해당 코루틴은 중지된 것으로 판단된다.</p>

<h2 id="dispatcher">Dispatcher</h2>

<p>coroutine에서 Thread에 코루틴을 전달하는 스케줄러 역할을 한다.</p>

<h1 id="structured-concurrency">Structured Concurrency</h1>

<h2 id="coroutine-scope">Coroutine <strong>S</strong>cope</h2>

<p>coroutineScope는 구조적 동시성을 구현한다.</p>

<ul>
  <li>상위 코루틴이 취소되면 하위 코루틴도 취소</li>
  <li>하위 코루틴이 예외를 발생시키면 상위 코루틴도 중지</li>
</ul>

<p>coroutineScope는 실행이 끝날 때까지 이전 코루틴의 실행을 일시 중단하는 새로운 코루틴을 생성한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutine</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="nf">minjuIsComing</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="nf">minjuIsGoing</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuIsComing</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주가 오고 있어요!"</span><span class="p">)</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">500L</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주가 도착했어요!"</span><span class="p">)</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuIsGoing</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주가 가고 있어요ㅜㅜ"</span><span class="p">)</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">1000L</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주가 가버렸어요ㅜㅜ"</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>17:23:26.285 [main] INFO **MainLogger** - start
17:23:26.378 [**main**] INFO Example - 민주가 오고 있어요!
17:23:27.013 [kotlinx.coroutines.DefaultExecutor] INFO Example - 민주가 도착했어요!
17:23:27.031 [kotlinx.coroutines.DefaultExecutor] INFO Example - 민주가 가고 있어요ㅜㅜ
17:23:28.041 [kotlinx.coroutines.DefaultExecutor] INFO Example - 민주가 가버렸어요ㅜㅜ
17:23:28.056 [kotlinx.coroutines.**DefaultExecutor**] INFO **MainLogger** - end
</code></pre></div></div>

<p>실행은 순전히 순차적이다. 하지만 런타임은 두 개의 서로 다른 스레드를 사용해 전체 프로세스를 실행한다.</p>

<p>코루틴에서 중단이 되었다 다시 재개할 때 중단 되었던 스레드에서 다시 시작한다는 보장이 없다.</p>

<p>⇒ 재개할 시엔 다른 스레드에서 실행될 수 있다.</p>

<h2 id="coroutine-builder">Coroutine Builder</h2>

<p>코루틴을 생성할 수 있다.</p>

<h3 id="launch-builder"><strong>Launch</strong> Builder</h3>

<p>특정 코드를 실행하지만, 그 결과값이 필요없을 때 사용된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutine</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">minjuIsComing</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">minjuIsGoing</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>18:44:54.289 [main] INFO MainLogger - start
18:44:54.856 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!
18:44:54.961 [DefaultDispatcher-worker-2] INFO Example - 민주가 가고 있어요ㅜㅜ
18:44:55.554 [DefaultDispatcher-worker-2] INFO Example - 민주가 도착했어요!
18:44:56.042 [DefaultDispatcher-worker-2] INFO Example - 민주가 가버렸어요ㅜㅜ
18:44:56.043 [DefaultDispatcher-worker-2] INFO MainLogger - end
</code></pre></div></div>

<p>위의 실행 결과 처럼 하나의 스코프 안에서 두 개의 코루틴을 동시에 실행한다. 두 개의 worker 스레드를 이용하여 처리한 것을 볼 수 있다.</p>

<ul>
  <li>두 코루틴은 동일한 범위의 하위 항목이므로 두 코루틴 모두 실행이 끝날 때까지 기다린 후 반환</li>
</ul>

<p><strong>GlobalScope</strong></p>

<p>GlobalScope를 사용해 구조적 동시성 사용을 피할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutineGlobal</span><span class="p">()</span> <span class="p">{</span>
    <span class="nc">GlobalScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
        <span class="nf">minjuIsComing</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nc">GlobalScope</span><span class="p">.</span><span class="nf">launch</span> <span class="p">{</span>
        <span class="nf">minjuIsGoing</span><span class="p">()</span>
    <span class="p">}</span>
    <span class="nc">Thread</span><span class="p">.</span><span class="nf">sleep</span><span class="p">(</span><span class="mi">1500L</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>18:56:07.017 [main] INFO MainLogger - start
18:56:07.409 [DefaultDispatcher-worker-1] INFO Example - 민주가 가고 있어요ㅜㅜ
18:56:07.409 [DefaultDispatcher-worker-3] INFO Example - 민주가 오고 있어요!
18:56:07.947 [DefaultDispatcher-worker-1] INFO Example - 민주가 도착했어요!
18:56:08.448 [DefaultDispatcher-worker-1] INFO Example - 민주가 가버렸어요ㅜㅜ
18:56:08.908 [main] INFO MainLogger - end
</code></pre></div></div>

<p>하지만, 이 경우엔 코루틴 실행이 끝날 때까지 약간의 대기 시간을 추가 해야한다.
(delay(1500L) 또는Thread.sleep(1500L)..)</p>

<ul>
  <li>부모-자식 관계를 강제하지 않는 빈 코루틴 범위와 같다.</li>
</ul>

<p><strong>Job</strong></p>

<p>launch 함수를 사용하면 Job을 반환한다.</p>

<ul>
  <li>Job은 <strong>코루틴에 대한 핸들러이다.</strong></li>
  <li>이를 사용하여 코루틴 실행을 취소하거나 완료될 때까지 기다릴 수 있다.</li>
</ul>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutineJob</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">minjuIsComingJob</span><span class="p">:</span> <span class="nc">Job</span> <span class="p">=</span> <span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">minjuIsComing</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="kd">val</span>  <span class="py">minjuIsGoingJob</span><span class="p">:</span> <span class="nc">Job</span> <span class="p">=</span> <span class="nf">launch</span> <span class="p">{</span>
             <span class="nf">minjuIsGoing</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">minjuIsComingJob</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
        <span class="n">minjuIsGoingJob</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
        <span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">minjuStartAndEnd</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>19:07:23.041 [main] INFO MainLogger - start
19:07:23.530 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!
19:07:23.548 [DefaultDispatcher-worker-2] INFO Example - 민주가 가고 있어요ㅜㅜ
19:07:24.145 [DefaultDispatcher-worker-1] INFO Example - 민주가 도착했어요!
19:07:24.627 [DefaultDispatcher-worker-1] INFO Example - 민주가 가버렸어요ㅜㅜ
19:07:24.648 [DefaultDispatcher-worker-2] INFO Example - 민주가 시작했어요!
19:07:25.163 [DefaultDispatcher-worker-2] INFO Example - 민주가 끝났어요!
19:07:25.164 [DefaultDispatcher-worker-2] INFO MainLogger - end
</code></pre></div></div>

<p>스코프 내의 3개의 코루틴이 동시에 실행될 것 같지만 아니다.</p>

<p>로그를 확인해 보면 minjuStartAndEnd는 나머지 두 개의 코루틴이 끝나고서야 실행되는 것을 확인할 수 있다.</p>

<p>이것이 구조적 동시성이다.</p>

<p>위의 코드에선 Job 객체를 통해 Join을 해주어 구조적 동시성을 달성했지만, 우리는 코드를 어떻게 바꿔야할 지 알고 있다</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutineJob</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="nf">coroutineScope</span> <span class="p">{</span>
            <span class="nf">launch</span> <span class="p">{</span>
                <span class="nf">minjuIsComing</span><span class="p">()</span>
            <span class="p">}</span>
            <span class="nf">launch</span> <span class="p">{</span>
                <span class="nf">minjuIsGoing</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">minjuStartAndEnd</span><span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>19:14:55.673 [main] INFO MainLogger - start
19:14:55.854 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!
19:14:55.861 [DefaultDispatcher-worker-2] INFO Example - 민주가 가고 있어요ㅜㅜ
19:14:56.412 [DefaultDispatcher-worker-2] INFO Example - 민주가 도착했어요!
19:14:56.906 [DefaultDispatcher-worker-2] INFO Example - 민주가 가버렸어요ㅜㅜ
19:14:56.911 [DefaultDispatcher-worker-2] INFO Example - 민주가 시작했어요!
19:14:57.413 [DefaultDispatcher-worker-2] INFO Example - 민주가 끝났어요!
19:14:57.413 [DefaultDispatcher-worker-2] INFO MainLogger - end
</code></pre></div></div>

<p>coroutineScope를 사용해 같은 결과를 얻을 수 있다.</p>

<h3 id="async-builder"><strong>Async Builder</strong></h3>

<p>코루틴 실행에서 결과 값을 반환해야할 때 사용한다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minju</span><span class="p">():</span> <span class="nc">String</span> <span class="p">{</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주 생성 중~~"</span><span class="p">)</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">500L</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"생성 완료!"</span><span class="p">)</span>
    <span class="k">return</span> <span class="s">"민주"</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">findMinju</span><span class="p">():</span> <span class="nc">Int</span> <span class="p">{</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주 찾는 중~~"</span><span class="p">)</span>
    <span class="nf">delay</span><span class="p">(</span><span class="mi">1000L</span><span class="p">)</span>
    <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"찾았습니다!"</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">511</span>
<span class="p">}</span>

<span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutineAsync</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="kd">val</span> <span class="py">minju</span><span class="p">:</span> <span class="nc">Deferred</span><span class="p">&lt;</span><span class="nc">String</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">async</span> <span class="p">{</span>
            <span class="nf">minju</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="kd">val</span> <span class="py">findMinju</span><span class="p">:</span> <span class="nc">Deferred</span><span class="p">&lt;</span><span class="nc">Int</span><span class="p">&gt;</span> <span class="p">=</span> <span class="nf">async</span> <span class="p">{</span>
            <span class="nf">findMinju</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"${minju.await()}를 ${findMinju.await()}일 만에 찾았습니다!"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>20:30:35.294 [main] INFO MainLogger - start
20:30:35.459 [DefaultDispatcher-worker-1] INFO Example - 민주 생성 중~~
20:30:35.476 [DefaultDispatcher-worker-2] INFO Example - 민주 찾는 중~~
20:30:36.004 [DefaultDispatcher-worker-1] INFO Example - 생성 완료!
20:30:36.499 [DefaultDispatcher-worker-1] INFO Example - 찾았습니다!
20:30:36.501 [DefaultDispatcher-worker-1] INFO Example - 민주를 511일 만에 찾았습니다!
20:30:36.501 [DefaultDispatcher-worker-1] INFO MainLogger - end
</code></pre></div></div>

<p>Deferred 변수에 async 실행 결과를 저장하고, await을 통해 값을 가져온다.(기다린다)</p>

<h1 id="cancellation">Cancellation</h1>

<p>코루틴 실행을 취소해보자</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">cancelMinjuRoutine</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span> 
        <span class="kd">val</span> <span class="py">minjuJob</span><span class="p">:</span> <span class="nc">Job</span> <span class="p">=</span> <span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">minjuIsComing</span><span class="p">()</span>
        <span class="p">}</span>
        <span class="nf">launch</span> <span class="p">{</span>
            <span class="nf">delay</span><span class="p">(</span><span class="mi">400L</span><span class="p">)</span>
            <span class="n">minjuJob</span><span class="p">.</span><span class="nf">cancel</span><span class="p">()</span>
            <span class="n">minjuJob</span><span class="p">.</span><span class="nf">join</span><span class="p">()</span>
            <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"민주가 사라졌어요.."</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>16:49:58.741 [main] INFO MainLogger - start
16:49:59.027 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!
16:49:59.483 [DefaultDispatcher-worker-1] INFO Example - 민주가 사라졌어요..
16:49:59.484 [DefaultDispatcher-worker-1] INFO MainLogger - end
</code></pre></div></div>

<p>민주가 오다가 사라져버린다.. 이 얼마나 안타까운 일인가;;</p>

<p>Job 또는 Deferred 클래스에서 cancel 함수를 구현해 코루틴을 취소할 수 있다.</p>

<p>하지만 코루틴의 실행을 취소 시키려면 일시 중지(delay)가 무조건 필요하다.</p>

<p>단순히 cancel만 사용하게 된다면, 해당 코루틴은 <strong>즉시 중지되지 않고,</strong> 계속 실행될 수 있다.</p>

<ul>
  <li>cancel 함수는 <strong>취소 중</strong>이라는 상태를 나타낸다.</li>
</ul>

<p>이런 실행 취소 신호(CancellationException)를 보내 감지를 해야하는데, 일시 중지 상태에서 해당 코루틴이 취소된 것을 알 수 있다.</p>

<p>cancel-join은 일반적인 패턴이라 Job.cancelAndJoin()을 통해 결합된 함수를 사용할 수 있다.</p>

<p>코루틴의 취소는 하위 코루틴까지 전파가 된다(코드는 따로 안 줄거임)</p>

<p>⇒ 코루틴을 취소하면 모든 자식이 암시적으로 취소가 됌</p>

<h1 id="coroutine-context">Coroutine Context</h1>

<p>상위 코루틴으로부터 하위 코루틴에게 전달된 정보를 저장하여 내부적으로 구조적 동시성을 달성하는 방법</p>

<ul>
  <li>CoroutineScope는 Coroutine context 참조를 유지한다.</li>
</ul>

<p>⇒ 자식까지 전염된다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutineContext</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="nf">launch</span><span class="p">(</span><span class="nc">CoroutineName</span><span class="p">(</span><span class="s">"아일릿-민주"</span><span class="p">)</span> <span class="p">+</span> <span class="nc">Dispatchers</span><span class="p">.</span><span class="nc">Default</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"Hello, Minju!"</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>17:05:15.688 [DefaultDispatcher-worker-1 @**아일릿-민주**#1] INFO Example - Hello, Minju!
</code></pre></div></div>

<p>해당 로그에서 코루틴이 지정된 이름으로 생성되고, 실행되는 것을 확인할 수 있다.</p>

<div class="language-kotlin highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">suspend</span> <span class="k">fun</span> <span class="nf">minjuRoutineContext</span><span class="p">()</span> <span class="p">{</span>
    <span class="nf">coroutineScope</span> <span class="p">{</span>
        <span class="nf">launch</span><span class="p">(</span><span class="nc">CoroutineName</span><span class="p">(</span><span class="s">"아일릿-민주"</span><span class="p">)</span> <span class="p">+</span> <span class="nc">Dispatchers</span><span class="p">.</span><span class="nc">Default</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"Hello, Minju!"</span><span class="p">)</span>
            <span class="nf">launch</span> <span class="p">{</span>
                <span class="n">log</span><span class="p">.</span><span class="nf">info</span><span class="p">(</span><span class="s">"Lovely Minju!"</span><span class="p">)</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>17:09:45.482 [main] INFO MainLogger - start
17:09:45.699 [DefaultDispatcher-worker-1 **@아일릿-민주#1**] INFO Example - Hello, Minju!
17:09:45.711 [DefaultDispatcher-worker-2 **@아일릿-민주#2**] INFO Example - Lovely Minju!
17:09:45.712 [DefaultDispatcher-worker-2 **@아일릿-민주#2**] INFO MainLogger - end
</code></pre></div></div>

<p>하위 코루틴까지 Context Name이 전염(전달)되는 것을 확인할 수 있다.</p>]]></content><author><name></name></author><category term="language" /><category term="Kotlin" /><category term="Coroutines" /><summary type="html"><![CDATA[코틀린 진영에서의 자바 가상 스레드와 같은 경량 동시성 모델]]></summary></entry><entry><title type="html">ForkJoinPool</title><link href="http://localhost:4000/blog/language/forkjoinpool/" rel="alternate" type="text/html" title="ForkJoinPool" /><published>2024-04-30T00:00:00+09:00</published><updated>2024-04-30T00:00:00+09:00</updated><id>http://localhost:4000/blog/language/forkjoinpool</id><content type="html" xml:base="http://localhost:4000/blog/language/forkjoinpool/"><![CDATA[<h2 id="forkjoinpool이란">ForkJoinPool이란?</h2>
<p>Fork/Join 프레임워크 기반으로 작업을 병렬로 실행하고 작업을 더 작은 하위 작업으로 나누고, 최종 결과로 결합하는 ForkJoinTask를 위한 스레드 풀이다. (ExecutorService 구현)</p>

<h2 id="work-stealing-algo">Work stealing algo</h2>

<p>작업을 마친 작업자 스레드가 다른 스레드에서 보류 중인 작업을 훔칠 수 있는 전략</p>

<ul>
  <li>병렬 실행에서는 작업이 여러 프로세서/코어로 나누어지는데 idle 상태가 되면 오버헤드 발생으로 다른 프로세서의 오버로드된 대기열(작업 대기열)에서 작업을 할당 받아야한다.</li>
</ul>

<h1 id="forkjoin">Fork/Join</h1>

<h2 id="fork">Fork</h2>

<p>작업을 분할/분해</p>

<ul>
  <li>작업을 스레드 풀의 작업 큐에 넣는다.</li>
  <li>비동기 메서드</li>
</ul>

<h2 id="join">Join</h2>

<p>풀 작업의 결과를 결합</p>

<ul>
  <li>동기 메서드</li>
</ul>

<h1 id="예제">예제</h1>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Main</span> <span class="o">{</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kt">void</span> <span class="nf">main</span><span class="o">(</span><span class="nc">String</span><span class="o">[]</span> <span class="n">args</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">long</span><span class="o">[</span><span class="mi">1_000_000</span><span class="o">];</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
            <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">;</span>
        <span class="o">}</span>

        <span class="nc">ForkJoinPool</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">ForkJoinPool</span><span class="o">();</span>
        <span class="nc">Task</span> <span class="n">task</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Task</span><span class="o">(</span><span class="n">numbers</span><span class="o">,</span> <span class="mi">0</span><span class="o">,</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">);</span>
        <span class="kt">long</span> <span class="n">result</span> <span class="o">=</span> <span class="n">pool</span><span class="o">.</span><span class="na">invoke</span><span class="o">(</span><span class="n">task</span><span class="o">);</span>
        <span class="nc">System</span><span class="o">.</span><span class="na">out</span><span class="o">.</span><span class="na">println</span><span class="o">(</span><span class="s">"Sum: "</span> <span class="o">+</span> <span class="n">result</span><span class="o">);</span>

        <span class="n">pool</span><span class="o">.</span><span class="na">shutdown</span><span class="o">();</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">class</span> <span class="nc">Task</span> <span class="kd">extends</span> <span class="nc">RecursiveTask</span><span class="o">&lt;</span><span class="nc">Long</span><span class="o">&gt;</span> <span class="o">{</span>
    <span class="kd">private</span> <span class="kd">final</span> <span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">start</span><span class="o">;</span>
    <span class="kd">private</span> <span class="kt">int</span> <span class="n">end</span><span class="o">;</span>

    <span class="kd">public</span> <span class="nf">Task</span><span class="o">(</span><span class="kt">long</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">start</span><span class="o">,</span> <span class="kt">int</span> <span class="n">end</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">this</span><span class="o">.</span><span class="na">numbers</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">start</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span>
        <span class="k">this</span><span class="o">.</span><span class="na">end</span> <span class="o">=</span> <span class="n">end</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="nd">@Override</span>
    <span class="kd">protected</span> <span class="nc">Long</span> <span class="nf">compute</span><span class="o">()</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">length</span> <span class="o">&lt;=</span> <span class="mi">100</span><span class="o">)</span> <span class="o">{</span>
            <span class="kt">long</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>

            <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">start</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
                <span class="n">sum</span> <span class="o">+=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
            <span class="o">}</span>
            <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="kt">int</span> <span class="n">middle</span> <span class="o">=</span> <span class="n">start</span> <span class="o">+</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
        <span class="nc">Task</span> <span class="n">leftTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Task</span><span class="o">(</span><span class="n">numbers</span><span class="o">,</span> <span class="n">start</span><span class="o">,</span> <span class="n">middle</span><span class="o">);</span>
        <span class="nc">Task</span> <span class="n">rightTask</span> <span class="o">=</span> <span class="k">new</span> <span class="nc">Task</span><span class="o">(</span><span class="n">numbers</span><span class="o">,</span> <span class="n">middle</span><span class="o">,</span> <span class="n">end</span><span class="o">);</span>

        <span class="n">leftTask</span><span class="o">.**</span><span class="n">fork</span><span class="o">**();</span>
        <span class="nc">Long</span> <span class="n">rightResult</span> <span class="o">=</span> <span class="n">rightTask</span><span class="o">.</span><span class="na">compute</span><span class="o">();</span>
        <span class="nc">Long</span> <span class="n">leftResult</span> <span class="o">=</span> <span class="n">leftTask</span><span class="o">.**</span><span class="n">join</span><span class="o">**();</span>

        <span class="k">return</span> <span class="n">leftResult</span> <span class="o">+</span> <span class="n">rightResult</span><span class="o">;</span>
    <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>]]></content><author><name></name></author><category term="language" /><category term="Java" /><category term="ForkJoinPool" /><category term="Parallelism" /><summary type="html"><![CDATA[ForkJoinPool이란? Fork/Join 프레임워크 기반으로 작업을 병렬로 실행하고 작업을 더 작은 하위 작업으로 나누고, 최종 결과로 결합하는 ForkJoinTask를 위한 스레드 풀이다. (ExecutorService 구현)]]></summary></entry></feed>