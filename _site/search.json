[
  
    {
      "title": "정렬 알고리즘 비교",
      "url": "/blog/algorithms/sorting-algorithms/",
      "date": "2023년 12월 10일",
      "categories": ["algorithms"],
      "tags": ["정렬","알고리즘","시간복잡도"],
      "content": "정렬 알고리즘은 컴퓨터 과학에서 가장 기본적이고 중요한 알고리즘 중 하나입니다. 이 글에서는 주요 정렬 알고리즘의 작동 방식, 시간 복잡도, 그리고 각각의 장단점을 비교해 보겠습니다.\n\n버블 정렬 (Bubble Sort)\n\n버블 정렬은 가장 단순한 정렬 알고리즘 중 하나로, 인접한 두 원소를 비교하여 필요한 경우 위치를 교환하는 방식으로 동작합니다.\n\n```javascript\nfunction bubbleSort(arr) {\n  const n = arr.length;\n\nfor (let i = 0; i &lt; n; i++) {\n    for (let j = 0; j &lt; n - i - 1; j++) {\n      if (arr[j] &gt; arr[j + 1]) {\n        // 두 원소 교환\n        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];\n      }\n    }\n  }\n\nreturn arr;\n}\n```\n\n\n  시간 복잡도: O(n²)\n  공간 복잡도: O(1)\n  장점: 구현이 매우 간단함\n  단점: 대규모 데이터셋에서는 매우 비효율적임\n\n\n선택 정렬 (Selection Sort)\n\n선택 정렬은 배열에서 최소값을 찾아 맨 앞으로 이동시키는 과정을 반복하는 알고리즘입니다.\n\n```javascript\nfunction selectionSort(arr) {\n  const n = arr.length;\n\nfor (let i = 0; i &lt; n; i++) {\n    let minIndex = i;\n\nfor (let j = i + 1; j &lt; n; j++) {\n  if (arr[j] &lt; arr[minIndex]) {\n    minIndex = j;\n  }\n}\n\nif (minIndex !== i) {\n  // 두 원소 교환\n  [arr[i], arr[minIndex]] = [arr[minIndex], arr[i]];\n}   }\n\n\nreturn arr;\n}\n```\n\n\n  시간 복잡도: O(n²)\n  공간 복잡도: O(1)\n  장점: 교환 연산의 수가 버블 정렬보다 적음\n  단점: 여전히 대규모 데이터셋에서는 비효율적임\n\n\n삽입 정렬 (Insertion Sort)\n\n삽입 정렬은 배열의 각 원소를 이미 정렬된 부분 배열의 적절한 위치에 삽입하는 알고리즘입니다.\n\n```javascript\nfunction insertionSort(arr) {\n  const n = arr.length;\n\nfor (let i = 1; i &lt; n; i++) {\n    const key = arr[i];\n    let j = i - 1;\n\nwhile (j &gt;= 0 &amp;&amp; arr[j] &gt; key) {\n  arr[j + 1] = arr[j];\n  j--;\n}\n\narr[j + 1] = key;   }\n\n\nreturn arr;\n}\n```\n\n\n  시간 복잡도: 평균 및 최악의 경우 O(n²), 최선의 경우 O(n)\n  공간 복잡도: O(1)\n  장점: 작은 데이터셋이나 거의 정렬된 데이터에서 효율적임\n  단점: 대규모 데이터셋에서는 여전히 비효율적임\n\n\n병합 정렬 (Merge Sort)\n\n병합 정렬은 분할 정복 방식을 사용하는 알고리즘으로, 배열을 반으로 나누고 각 부분을 정렬한 후 병합하는 과정을 반복합니다.\n\n```javascript\nfunction mergeSort(arr) {\n  if (arr.length &lt;= 1) {\n    return arr;\n  }\n\nconst mid = Math.floor(arr.length / 2);\n  const left = mergeSort(arr.slice(0, mid));\n  const right = mergeSort(arr.slice(mid));\n\nreturn merge(left, right);\n}\n\nfunction merge(left, right) {\n  const result = [];\n  let leftIndex = 0;\n  let rightIndex = 0;\n\nwhile (leftIndex &lt; left.length &amp;&amp; rightIndex &lt; right.length) {\n    if (left[leftIndex] &lt; right[rightIndex]) {\n      result.push(left[leftIndex]);\n      leftIndex++;\n    } else {\n      result.push(right[rightIndex]);\n      rightIndex++;\n    }\n  }\n\nreturn result.concat(left.slice(leftIndex)).concat(right.slice(rightIndex));\n}\n```\n\n\n  시간 복잡도: O(n log n)\n  공간 복잡도: O(n)\n  장점: 안정적인 성능, 대규모 데이터셋에서도 효율적임\n  단점: 추가 메모리 공간이 필요함\n\n\n퀵 정렬 (Quick Sort)\n\n퀵 정렬도 분할 정복 방식을 사용하는 알고리즘으로, 피벗을 선택하여 피벗보다 작은 원소와 큰 원소로 분할한 후 각 부분을 재귀적으로 정렬합니다.\n\n```javascript\nfunction quickSort(arr, left = 0, right = arr.length - 1) {\n  if (left &lt; right) {\n    const pivotIndex = partition(arr, left, right);\n    quickSort(arr, left, pivotIndex - 1);\n    quickSort(arr, pivotIndex + 1, right);\n  }\n\nreturn arr;\n}\n\nfunction partition(arr, left, right) {\n  const pivot = arr[right];\n  let i = left - 1;\n\nfor (let j = left; j &lt; right; j++) {\n    if (arr[j] &lt;= pivot) {\n      i++;\n      [arr[i], arr[j]] = [arr[j], arr[i]];\n    }\n  }\n\n[arr[i + 1], arr[right]] = [arr[right], arr[i + 1]];\n  return i + 1;\n}\n```\n\n\n  시간 복잡도: 평균 O(n log n), 최악의 경우 O(n²)\n  공간 복잡도: O(log n)\n  장점: 실제 구현에서 매우 빠른 성능을 보임, 추가 메모리 공간이 적게 필요함\n  단점: 최악의 경우 성능이 저하될 수 있음, 불안정 정렬임\n\n\n힙 정렬 (Heap Sort)\n\n힙 정렬은 이진 힙 자료구조를 사용하여 배열을 정렬하는 알고리즘입니다.\n\n```javascript\nfunction heapSort(arr) {\n  const n = arr.length;\n\n// 최대 힙 구성\n  for (let i = Math.floor(n / 2) - 1; i &gt;= 0; i–) {\n    heapify(arr, n, i);\n  }\n\n// 힙에서 요소를 하나씩 추출\n  for (let i = n - 1; i &gt; 0; i–) {\n    [arr[0], arr[i]] = [arr[i], arr[0]];\n    heapify(arr, i, 0);\n  }\n\nreturn arr;\n}\n\nfunction heapify(arr, n, i) {\n  let largest = i;\n  const left = 2 * i + 1;\n  const right = 2 * i + 2;\n\nif (left &lt; n &amp;&amp; arr[left] &gt; arr[largest]) {\n    largest = left;\n  }\n\nif (right &lt; n &amp;&amp; arr[right] &gt; arr[largest]) {\n    largest = right;\n  }\n\nif (largest !== i) {\n    [arr[i], arr[largest]] = [arr[largest], arr[i]];\n    heapify(arr, n, largest);\n  }\n}\n```\n\n\n  시간 복잡도: O(n log n)\n  공간 복잡도: O(1)\n  장점: 추가 메모리 공간이 필요하지 않음, 최악의 경우에도 O(n log n) 성능 보장\n  단점: 불안정 정렬임, 실제 구현에서 퀵 정렬보다 느린 경우가 많음\n\n\n정렬 알고리즘 비교\n\n\n  \n    \n      알고리즘\n      시간 복잡도 (평균)\n      시간 복잡도 (최악)\n      공간 복잡도\n      안정성\n    \n  \n  \n    \n      버블 정렬\n      O(n²)\n      O(n²)\n      O(1)\n      안정\n    \n    \n      선택 정렬\n      O(n²)\n      O(n²)\n      O(1)\n      불안정\n    \n    \n      삽입 정렬\n      O(n²)\n      O(n²)\n      O(1)\n      안정\n    \n    \n      병합 정렬\n      O(n log n)\n      O(n log n)\n      O(n)\n      안정\n    \n    \n      퀵 정렬\n      O(n log n)\n      O(n²)\n      O(log n)\n      불안정\n    \n    \n      힙 정렬\n      O(n log n)\n      O(n log n)\n      O(1)\n      불안정\n    \n  \n\n\n결론\n\n정렬 알고리즘의 선택은 데이터의 크기, 초기 정렬 상태, 메모리 제약, 안정성 요구 사항 등 여러 요소에 따라 달라집니다.\n\n\n  작은 데이터셋: 삽입 정렬이 간단하고 효율적\n  대규모 데이터셋: 퀵 정렬, 병합 정렬, 힙 정렬이 적합\n  메모리 제약이 있는 경우: 힙 정렬이나 퀵 정렬이 좋은 선택\n  안정성이 중요한 경우: 병합 정렬이나 삽입 정렬이 적합\n\n\n실제 프로그래밍 언어의 내장 정렬 함수는 대부분 퀵 정렬이나 병합 정렬의 변형, 또는 두 알고리즘을 조합한 하이브리드 정렬 알고리즘을 사용합니다.\n"
    },
  
    {
      "title": "Express로 REST API 만들기",
      "url": "/blog/backend/express-rest-api/",
      "date": "2023년 11월 05일",
      "categories": ["backend"],
      "tags": ["Node.js","Express","REST API"],
      "content": "Express는 Node.js를 위한 빠르고 간결한 웹 프레임워크로, REST API를 구축하는 데 널리 사용됩니다. 이 글에서는 Express를 사용하여 기본적인 REST API를 만드는 방법을 알아보겠습니다.\n\nExpress 설치 및 기본 설정\n\n먼저 새 프로젝트를 생성하고 Express를 설치합니다:\n\n```bash\nmkdir express-api\ncd express-api\nnpm init -y\nnpm install express\n```\n\n이제 기본적인 Express 서버를 설정해 보겠습니다:\n\n```javascript\n// app.js\nconst express = require(‘express’);\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// JSON 요청 본문 파싱\napp.use(express.json());\n\n// 기본 라우트\napp.get(‘/’, (req, res) =&gt; {\n  res.json({ message: ‘Express REST API에 오신 것을 환영합니다!’ });\n});\n\n// 서버 시작\napp.listen(port, () =&gt; {\n  console.log(서버가 http://localhost:${port} 에서 실행 중입니다);\n});\n```\n\nREST API 엔드포인트 구현\n\n이제 사용자 리소스에 대한 CRUD(Create, Read, Update, Delete) 작업을 수행하는 REST API 엔드포인트를 구현해 보겠습니다:\n\n```javascript\n// app.js\nconst express = require(‘express’);\nconst app = express();\nconst port = process.env.PORT || 3000;\n\n// JSON 요청 본문 파싱\napp.use(express.json());\n\n// 메모리 내 사용자 데이터 (실제 애플리케이션에서는 데이터베이스 사용)\nlet users = [\n  { id: 1, name: ‘홍길동’, email: ‘hong@example.com’ },\n  { id: 2, name: ‘김철수’, email: ‘kim@example.com’ }\n];\n\n// 모든 사용자 조회 (READ)\napp.get(‘/api/users’, (req, res) =&gt; {\n  res.json(users);\n});\n\n// 특정 사용자 조회 (READ)\napp.get(‘/api/users/:id’, (req, res) =&gt; {\n  const id = parseInt(req.params.id);\n  const user = users.find(user =&gt; user.id === id);\n\nif (!user) {\n    return res.status(404).json({ message: ‘사용자를 찾을 수 없습니다’ });\n  }\n\nres.json(user);\n});\n\n// 새 사용자 생성 (CREATE)\napp.post(‘/api/users’, (req, res) =&gt; {\n  const { name, email } = req.body;\n\nif (!name || !email) {\n    return res.status(400).json({ message: ‘이름과 이메일은 필수 항목입니다’ });\n  }\n\nconst newId = users.length &gt; 0 ? Math.max(…users.map(user =&gt; user.id)) + 1 : 1;\n  const newUser = { id: newId, name, email };\n\nusers.push(newUser);\n  res.status(201).json(newUser);\n});\n\n// 사용자 정보 업데이트 (UPDATE)\napp.put(‘/api/users/:id’, (req, res) =&gt; {\n  const id = parseInt(req.params.id);\n  const { name, email } = req.body;\n\nif (!name || !email) {\n    return res.status(400).json({ message: ‘이름과 이메일은 필수 항목입니다’ });\n  }\n\nconst userIndex = users.findIndex(user =&gt; user.id === id);\n\nif (userIndex === -1) {\n    return res.status(404).json({ message: ‘사용자를 찾을 수 없습니다’ });\n  }\n\nusers[userIndex] = { id, name, email };\n  res.json(users[userIndex]);\n});\n\n// 사용자 삭제 (DELETE)\napp.delete(‘/api/users/:id’, (req, res) =&gt; {\n  const id = parseInt(req.params.id);\n  const userIndex = users.findIndex(user =&gt; user.id === id);\n\nif (userIndex === -1) {\n    return res.status(404).json({ message: ‘사용자를 찾을 수 없습니다’ });\n  }\n\nconst deletedUser = users[userIndex];\n  users = users.filter(user =&gt; user.id !== id);\n\nres.json(deletedUser);\n});\n\n// 서버 시작\napp.listen(port, () =&gt; {\n  console.log(서버가 http://localhost:${port} 에서 실행 중입니다);\n});\n```\n\n미들웨어 사용\n\nExpress의 강력한 기능 중 하나는 미들웨어입니다. 미들웨어를 사용하여 요청 로깅, 오류 처리 등의 기능을 추가할 수 있습니다:\n\n```javascript\n// 요청 로깅 미들웨어\napp.use((req, res, next) =&gt; {\n  console.log(${new Date().toISOString()} - ${req.method} ${req.url});\n  next();\n});\n\n// 오류 처리 미들웨어\napp.use((err, req, res, next) =&gt; {\n  console.error(err.stack);\n  res.status(500).json({ message: ‘서버 오류가 발생했습니다’ });\n});\n```\n\n라우터 분리\n\n애플리케이션이 커지면 라우트를 별도의 파일로 분리하는 것이 좋습니다:\n\n```javascript\n// routes/users.js\nconst express = require(‘express’);\nconst router = express.Router();\n\n// 메모리 내 사용자 데이터\nlet users = [\n  { id: 1, name: ‘홍길동’, email: ‘hong@example.com’ },\n  { id: 2, name: ‘김철수’, email: ‘kim@example.com’ }\n];\n\n// 모든 사용자 조회\nrouter.get(‘/’, (req, res) =&gt; {\n  res.json(users);\n});\n\n// 특정 사용자 조회\nrouter.get(‘/:id’, (req, res) =&gt; {\n  const id = parseInt(req.params.id);\n  const user = users.find(user =&gt; user.id === id);\n\nif (!user) {\n    return res.status(404).json({ message: ‘사용자를 찾을 수 없습니다’ });\n  }\n\nres.json(user);\n});\n\n// 새 사용자 생성\nrouter.post(‘/’, (req, res) =&gt; {\n  const { name, email } = req.body;\n\nif (!name || !email) {\n    return res.status(400).json({ message: ‘이름과 이메일은 필수 항목입니다’ });\n  }\n\nconst newId = users.length &gt; 0 ? Math.max(…users.map(user =&gt; user.id)) + 1 : 1;\n  const newUser = { id: newId, name, email };\n\nusers.push(newUser);\n  res.status(201).json(newUser);\n});\n\n// 사용자 정보 업데이트\nrouter.put(‘/:id’, (req, res) =&gt; {\n  const id = parseInt(req.params.id);\n  const { name, email } = req.body;\n\nif (!name || !email) {\n    return res.status(400).json({ message: ‘이름과 이메일은 필수 항목입니다’ });\n  }\n\nconst userIndex = users.findIndex(user =&gt; user.id === id);\n\nif (userIndex === -1) {\n    return res.status(404).json({ message: ‘사용자를 찾을 수 없습니다’ });\n  }\n\nusers[userIndex] = { id, name, email };\n  res.json(users[userIndex]);\n});\n\n// 사용자 삭제\nrouter.delete(‘/:id’, (req, res) =&gt; {\n  const id = parseInt(req.params.id);\n  const userIndex = users.findIndex(user =&gt; user.id === id);\n\nif (userIndex === -1) {\n    return res.status(404).json({ message: ‘사용자를 찾을 수 없습니다’ });\n  }\n\nconst deletedUser = users[userIndex];\n  users = users.filter(user =&gt; user.id !== id);\n\nres.json(deletedUser);\n});\n\nmodule.exports = router;\n```\n\n```javascript\n// app.js\nconst express = require(‘express’);\nconst app = express();\nconst port = process.env.PORT || 3000;\nconst usersRouter = require(‘./routes/users’);\n\n// JSON 요청 본문 파싱\napp.use(express.json());\n\n// 요청 로깅 미들웨어\napp.use((req, res, next) =&gt; {\n  console.log(${new Date().toISOString()} - ${req.method} ${req.url});\n  next();\n});\n\n// 라우터 사용\napp.use(‘/api/users’, usersRouter);\n\n// 기본 라우트\napp.get(‘/’, (req, res) =&gt; {\n  res.json({ message: ‘Express REST API에 오신 것을 환영합니다!’ });\n});\n\n// 오류 처리 미들웨어\napp.use((err, req, res, next) =&gt; {\n  console.error(err.stack);\n  res.status(500).json({ message: ‘서버 오류가 발생했습니다’ });\n});\n\n// 서버 시작\napp.listen(port, () =&gt; {\n  console.log(서버가 http://localhost:${port} 에서 실행 중입니다);\n});\n```\n\nAPI 테스트\n\nAPI를 테스트하기 위해 Postman이나 curl 명령어를 사용할 수 있습니다:\n\n```bash\n모든 사용자 조회\ncurl http://localhost:3000/api/users\n\n특정 사용자 조회\ncurl http://localhost:3000/api/users/1\n\n새 사용자 생성\ncurl -X POST -H “Content-Type: application/json” -d ‘{“name”:”이영희”,”email”:”lee@example.com”}’ http://localhost:3000/api/users\n\n사용자 정보 업데이트\ncurl -X PUT -H “Content-Type: application/json” -d ‘{“name”:”이영희”,”email”:”updated@example.com”}’ http://localhost:3000/api/users/3\n\n사용자 삭제\ncurl -X DELETE http://localhost:3000/api/users/3\n```\n\n결론\n\n이 글에서는 Express를 사용하여 기본적인 REST API를 구축하는 방법을 알아보았습니다. Express는 간결하면서도 강력한 기능을 제공하여 Node.js에서 API를 개발하는 데 이상적인 프레임워크입니다.\n\n실제 애플리케이션에서는 MongoDB, PostgreSQL 등의 데이터베이스를 연결하고, JWT를 사용한 인증, 입력 유효성 검사 등의 기능을 추가하여 더 견고한 API를 구축할 수 있습니다.\n"
    },
  
    {
      "title": "서버 컴포넌트 vs 클라이언트 컴포넌트",
      "url": "/blog/frontend/server-vs-client-components/",
      "date": "2023년 10월 20일",
      "categories": ["frontend"],
      "tags": ["Next.js","React","서버 컴포넌트"],
      "content": "Next.js 13에서 도입된 React Server Components는 웹 애플리케이션 개발 방식에 큰 변화를 가져왔습니다. 이 글에서는 서버 컴포넌트와 클라이언트 컴포넌트의 차이점과 각각의 사용 사례에 대해 알아보겠습니다.\n\n서버 컴포넌트와 클라이언트 컴포넌트의 차이점\n\n서버 컴포넌트\n\n서버 컴포넌트는 서버에서 렌더링되어 HTML로 변환된 후 클라이언트로 전송됩니다. 이는 다음과 같은 특징을 가집니다:\n\n\n  번들 크기 감소: 서버 컴포넌트의 JavaScript 코드는 클라이언트로 전송되지 않습니다.\n  데이터베이스 직접 접근: 서버 환경에서 실행되므로 데이터베이스에 직접 접근할 수 있습니다.\n  환경 변수 접근: 서버 측 환경 변수에 안전하게 접근할 수 있습니다.\n  캐싱: 서버에서 렌더링 결과를 캐싱하여 성능을 향상시킬 수 있습니다.\n\n\n하지만 서버 컴포넌트에서는 다음과 같은 제약이 있습니다:\n\n\n  상태 사용 불가: useState와 같은 React 훅을 사용할 수 없습니다.\n  이벤트 핸들러 사용 불가: onClick과 같은 이벤트 핸들러를 사용할 수 없습니다.\n  브라우저 API 접근 불가: window, document 등의 브라우저 API에 접근할 수 없습니다.\n\n\n클라이언트 컴포넌트\n\n클라이언트 컴포넌트는 기존의 React 컴포넌트와 동일하게 클라이언트에서 렌더링됩니다. ‘use client’ 지시문을 파일 상단에 추가하여 클라이언트 컴포넌트로 지정할 수 있습니다.\n\n```jsx\n‘use client’\n\nimport { useState } from ‘react’\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n\nreturn (\n    &lt;div&gt;\n      &lt;p&gt;카운트: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;증가&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n```\n\n클라이언트 컴포넌트는 다음과 같은 특징을 가집니다:\n\n\n  상태 및 효과 사용 가능: useState, useEffect 등의 React 훅을 사용할 수 있습니다.\n  이벤트 핸들러 사용 가능: 사용자 상호작용을 처리할 수 있습니다.\n  브라우저 API 접근 가능: 브라우저 환경의 API를 사용할 수 있습니다.\n\n\n언제 어떤 컴포넌트를 사용해야 할까?\n\n서버 컴포넌트를 사용해야 할 때\n\n\n  데이터 페칭이 필요한 경우: 데이터베이스나 API에서 데이터를 가져와야 할 때\n  민감한 정보에 접근해야 하는 경우: API 키, 토큰 등의 민감한 정보를 사용해야 할 때\n  대규모 의존성이 필요한 경우: 클라이언트로 전송되는 JavaScript 양을 줄이고 싶을 때\n  SEO가 중요한 정적 콘텐츠: 검색 엔진 최적화가 필요한 정적 콘텐츠\n\n\n클라이언트 컴포넌트를 사용해야 할 때\n\n\n  상호작용이 필요한 경우: 사용자 입력, 애니메이션 등의 상호작용이 필요할 때\n  상태 관리가 필요한 경우: 컴포넌트 내부 상태를 관리해야 할 때\n  브라우저 API를 사용해야 하는 경우: localStorage, window 등의 브라우저 API를 사용해야 할 때\n  이벤트 리스너가 필요한 경우: 클릭, 스크롤 등의 이벤트를 처리해야 할 때\n\n\n서버 컴포넌트와 클라이언트 컴포넌트의 조합\n\n실제 애플리케이션에서는 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 조합하여 사용하는 것이 좋습니다. 다음은 그 예시입니다:\n\n```jsx\n// app/page.tsx (서버 컴포넌트)\nimport { db } from ‘@/lib/db’\nimport ClientCounter from ‘@/components/client-counter’\n\nexport default async function Page() {\n  const products = await db.products.findMany()\n\nreturn (\n    &lt;div&gt;\n      &lt;h1&gt;제품 목록&lt;/h1&gt;\n      &lt;ul&gt;\n        {products.map(product =&gt; (\n          &lt;li key={product.id}&gt;{product.name}&lt;/li&gt;\n        ))}\n      &lt;/ul&gt;\n      \n    &lt;/div&gt;\n  )\n}\n```\n\n```jsx\n// components/client-counter.tsx (클라이언트 컴포넌트)\n‘use client’\n\nimport { useState } from ‘react’\n\nexport default function ClientCounter() {\n  const [count, setCount] = useState(0)\n\nreturn (\n    &lt;div&gt;\n      &lt;p&gt;카운트: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;증가&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n```\n\n이 예시에서는 서버 컴포넌트에서 데이터베이스에서 제품 목록을 가져오고, 클라이언트 컴포넌트에서 카운터 기능을 구현했습니다.\n\n결론\n\nNext.js 13의 App Router에서는 서버 컴포넌트와 클라이언트 컴포넌트를 적절히 조합하여 사용하는 것이 중요합니다. 각 컴포넌트의 특성을 이해하고, 상황에 맞게 선택하여 사용하면 더 효율적인 웹 애플리케이션을 구축할 수 있습니다.\n"
    },
  
    {
      "title": "Next.js 13 App Router 소개",
      "url": "/blog/frontend/nextjs-app-router/",
      "date": "2023년 10월 15일",
      "categories": ["frontend"],
      "tags": ["Next.js","React","프론트엔드"],
      "content": "Next.js 13에서 소개된 App Router는 React의 최신 기능을 활용하여 더 나은 개발자 경험과 성능을 제공합니다. 이 글에서는 App Router의 주요 기능과 장점에 대해 알아보겠습니다.\n\nApp Router란?\n\nApp Router는 Next.js의 새로운 라우팅 시스템으로, 기존의 Pages Router를 대체합니다. App Router는 React Server Components를 기반으로 하며, 파일 시스템 기반 라우팅을 사용합니다.\n\n주요 기능\n\n1. 서버 컴포넌트\n\nApp Router는 기본적으로 모든 컴포넌트를 서버 컴포넌트로 취급합니다. 서버 컴포넌트는 서버에서 렌더링되어 클라이언트로 전송되므로, 클라이언트 측 JavaScript 번들 크기를 줄일 수 있습니다.\n\n```jsx\n// app/page.tsx\n// 이 컴포넌트는 기본적으로 서버 컴포넌트입니다\nexport default function Page() {\n  return &lt;h1&gt;안녕하세요, Next.js!&lt;/h1&gt;\n}\n```\n\n2. 클라이언트 컴포넌트\n\n클라이언트 측 상호작용이 필요한 경우, ‘use client’ 지시문을 사용하여 클라이언트 컴포넌트를 만들 수 있습니다.\n\n```jsx\n// components/counter.tsx\n‘use client’\n\nimport { useState } from ‘react’\n\nexport default function Counter() {\n  const [count, setCount] = useState(0)\n\nreturn (\n    &lt;div&gt;\n      &lt;p&gt;카운트: {count}&lt;/p&gt;\n      &lt;button onClick={() =&gt; setCount(count + 1)}&gt;증가&lt;/button&gt;\n    &lt;/div&gt;\n  )\n}\n```\n\n3. 레이아웃\n\nApp Router는 중첩된 레이아웃을 쉽게 구현할 수 있게 해줍니다. layout.tsx 파일을 사용하여 여러 페이지에서 공유되는 UI 요소를 정의할 수 있습니다.\n\n```jsx\n// app/blog/layout.tsx\nexport default function BlogLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  return (\n    &lt;div&gt;\n      &lt;nav&gt;블로그 네비게이션&lt;/nav&gt;\n      &lt;main&gt;{children}&lt;/main&gt;\n      &lt;footer&gt;블로그 푸터&lt;/footer&gt;\n    &lt;/div&gt;\n  )\n}\n```\n\n4. 데이터 페칭\n\n서버 컴포넌트에서는 async/await를 사용하여 데이터를 가져올 수 있습니다. 이는 클라이언트 측 JavaScript 없이도 데이터를 가져올 수 있게 해줍니다.\n\n```jsx\n// app/posts/[id]/page.tsx\nasync function getPost(id) {\n  const res = await fetch(https://api.example.com/posts/${id})\n  return res.json()\n}\n\nexport default async function Post({ params }) {\n  const post = await getPost(params.id)\n\nreturn (\n    &lt;article&gt;\n      &lt;h1&gt;{post.title}&lt;/h1&gt;\n      &lt;p&gt;{post.content}&lt;/p&gt;\n    &lt;/article&gt;\n  )\n}\n```\n\n결론\n\nNext.js 13의 App Router는 React의 최신 기능을 활용하여 더 나은 개발자 경험과 성능을 제공합니다. 서버 컴포넌트, 중첩 레이아웃, 간소화된 데이터 페칭 등의 기능을 통해 더 효율적인 웹 애플리케이션을 구축할 수 있습니다.\n\n다음 글에서는 서버 컴포넌트와 클라이언트 컴포넌트의 차이점과 각각의 사용 사례에 대해 더 자세히 알아보겠습니다.\n"
    }
  
]
