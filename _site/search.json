[
  
    {
      "title": "PECS",
      "url": "/blog/language/pecs/",
      "date": "2024년 07월 28일",
      "categories": ["language"],
      "tags": ["Java","Generic","PECS"],
      "content": "Producer Extends Consumer Super\n\nPECS 원칙\n\n  Producer: 데이터를 생산하는 객체\n  Consumer: 데이터를 소비하는 객체\n\n\n원칙\n\n\n  Producer Extends: 데이터를 읽을 때는 extends 와일드카드를 사용 &lt;? extends T&gt;\n  \n    Consumer Super: 데이터를 쓸 때는 super 와일드카드를 사용 &lt;? super T&gt;\n  \n  &lt;? extends T&gt;: T 타입이나 T의 하위 타입만 허용 (읽기 전용)\n  &lt;? super T&gt;: T 타입이나 T의 상위 타입만 허용 (쓰기 가능)\n\n\n예시\n\n// Producer (읽기)\nList&lt;? extends Number&gt; numbers = new ArrayList&lt;&gt;();\nNumber n = numbers.get(0);  \n\n// Consumer (쓰기)\nList&lt;? super Integer&gt; integers = new ArrayList&lt;&gt;();\nintegers.add(10); \n\n\n\n  extends: 요소 추가 불가, 읽기만 가능\n  super: 요소 읽을 때 Object 타입으로만 가능\n\n\n왜 extends에서 쓰기는 불가능한가에 대해 더 살펴보겠다\n\nList&lt;? extends Number&gt; numbers = new ArrayList&lt;&gt;();\n\n\n이 경우에 numbers 리스트는 Number의 어떤 하위 타입이든 포함할 수 있따. &lt;? extends Number&gt; 이므로.\n\n근데? 컴파일러 입장에선 정확히 어떤 하위 타입인지 모른다. Integer인지 Double인지 ?\n\n타입을 모르니 numbers.add(new Integer(10))을 허용하면\n\n리스트가 ArrayList&lt;Double&gt;일 경우 타입 안전성이 깨진다.\n\n이런 이유로 쓰기가 불가능한 것이다.\n\nList&lt;? super Integer&gt; integers = new ArrayList&lt;&gt;();\n\n\n이 경우를 살펴보겠디.\n\nintegers 리스트는 Integer의 어떤 상위 타입이든 될 수 있다.\n\n뭐 Number일 수도, Object일 수도 있다.\n\n컴파일러는 정확한 타입을 모르니 가장 상위 타입인 Object로 읽을 수 있다.\n\n근데 왜 쓰기가 가능할까?\n당연한 것이다. Integer 타입이 Number든, Object든 상위 타입에 안전하게 들어갈 수 있으니 쓰기가 가능하다.\n"
    },
  
    {
      "title": "Java Throwing Exception",
      "url": "/blog/language/java-throwing-exception/",
      "date": "2024년 06월 17일",
      "categories": ["language"],
      "tags": ["Java","Exception","Exception Handling"],
      "content": "자바를 넘어서 모든 SW의 예외 처리는 매우 중요하다. \n이를 통해 개발자는 예상치 못한 오류를 적절하게 해결할 수 있어 해당 SW의 품질을 보장할 수 있는 그런 작업이다.\n\n자바 프로그래밍 내에서의 예외 처리를 이해해보자.\n\nException이란?\n\n자바 프로그래밍 내에서의 예외는 런타임 환경에서 발생하여, 프로그램이 정상적인 진행을 하지 못하게 하는 사건 즉 시스템은 올바르게 이루어져 있지만, 개발자의 로직의 오류를 말한다. \n보통 0으로 나누기, null인 객체에 접근, 존재하지 않는 파일에 접근 등의 예외 상황이 있다.\n\nThrow statement\n자바를 사용해 개발 또는 학습을 진행하였다면, throw, throws 등의 구문. 키워드를 본 적이 있을 것이다.\n\n예를 들면 이런 식이다.\nvoid method1() throws InterruptedException {\n\t\tThread.sleep(5000L);\n\t\t\n\t\tthrow new RuntimeException();\n} // 극단적인 예시.\n\n이 파트에선 throw. 메서드 바디 내에서 예외를 발생. 혹은 던지는 것을 학습할 것이다.\n\n자바에서 throw 구문을 사용해 예외를 발생시키는 것은 간단하다.\n\nthrow ThrowableObject; \n\n\nThrowableObject은 자바의 모든 예외에 대한 기본 클래스인 Throwable를 확장하는 클래스의 인스턴스이어야 한다.\n\n뭐 예를 들면 많이들 알고 있는 RuntimeException이라던가 예외들이 throw 구문 뒤에 위치할 수 있다.\n\nChecked.’ Unchecked Exception\n\nChecked Exception은 개발자가 무조건 처리해야하는 컴파일 시점에서 발생하는 오류이다.\n\n예로 들자면. Thread.sleep 메서드를 사용하고 싶을 때 일반 적인 메서드 블록에 작성하면 빨간 줄이 생기는 모습을 본 적이 있을 것이다.\n\n해당 에러를 확인하면. Unhandled exception: ..InterruptedException을 확인 할 수 있는데.\n\nInterruptedException를 핸들링 해줘야한다고 한다. 왜 그럴까?\n\npublic static void sleep(long millis) **throws InterruptedException** {\n    ...\n}\n\n\nsleep 메서드의 구현을 보니 throws InterruptedException이 작성되어 있는 걸 볼 수 있다.\n\n아! throws는 전염되는 구나! 그렇다. .\n\nthrows를 사용한 건 메서드 블록이 해당 예외를 발생시킬 수 있다고 작성한 것이고,\n\n왜 명시를 해야하는 걸까?\nInterruptedException은 checked exception으로 외부의 리소스, 서비스와 상호작용해야할 때 잠재적인 예외 상황을 기호화해서 예측할 수 없게 실패할 수 있는 오류 처리를 해야하기 때문이다.\n\nUnchecked Exception은 개발자의 예외 처리가 필수가 아니고, 런타임 시점에서 발생할 수 있는 예외이다.\n\n주로 코드의 결함이나, 논리적 문제에서 발생한다.\n\n예를 들면\n\n\n  유효한 범위가 아닌 배열 인덱스에 접근하였을 때 (ArrayIndexOutOfBoundsException)\n  null인 객체에 접근을 했을 때 (NullPointerException)\n\n\n발생하는 예외이다.\n\nSpring ControllerAdvice\n\nControllerAdvice 어노테이션을 자세히 알아보지는 않을 것이다.\n\n그저 독자들이 주로 스프링 부트를 사용해 애플리케이션을 개발하고 있을텐데, 전역적으로 예외를 잡아주는 ControllerAdvice를 사용할 거라 생각했다.\n\n그렇다면 본인은 Custom Exception을 직접 비즈니스에 맞게 작성하여 사용하고 있는가?\n\n정말 잘 사용하고 있을까?\n\n비즈니스 로직이 커지면 예외 상황은 더 늘어날 수 밖에 없다. 하지만 예외 처리를 할 때 생기는 비용을 생각해본 적이 있나?\n\n예외 생성 비용은 비싸다. 예외 발생 회수가 커질 수록 문제가 생길 수도 있다.\n\n예외 생성 비용에 가장 영향을 미치는 요소는 trace로 예외 발생 경로이다.\n\n이를 해결하기 위해 stack trace를 갖지 않도록 설정할 수 있는데,\n\n@Override\npublic synchronized Throwable fillInStackTrace() {\n  return this;\n}\n\n\n위와 같이 fillInStackTrace 메서드를 아무 stack trace를 갖지 않도록 override할 수 있다.\n\n또 위와 같이 생성했다면 static final 필드에 미리 예외를 캐싱해두고 사용하면 비용을 더 줄일 수 있을 것이다.\n"
    },
  
    {
      "title": "Coroutines",
      "url": "/blog/language/kotlin-coroutines/",
      "date": "2024년 05월 26일",
      "categories": ["language"],
      "tags": ["Kotlin","Coroutines"],
      "content": "코틀린 진영에서의 자바 가상 스레드와 같은 경량 동시성 모델\n\n왜 코루틴을 사용해야 하는가?\n\n코틀린에서 비동기 프로그래밍을 하기 위해?(맞음)\n\n비동기식 코드를 동기 방식으로 작성하기 위해(맞음) ⇒ 콜백지옥이 이제 없음(행복?)\n\n\n  코틀린 코루틴에선 콜백 스타일의 코드가 아닌 명령형 프로그래밍 스타일임.\n\n\n코루틴도 가상 스레드 처럼 OS 스레드에 직접 매핑되지 않고 continuations이라는 객체를 사용해 ULT에서 매핑이 이루어진다. (경량 스레드)\n\n⇒ 코루틴 간 전환(CS)에서는 OS가 다른 스레드의 컨텍스트를 로드할 필요가 없지만 참조를 continuations 객체로 전환해야한다.\n\n비동기라면서 왜 반응형 프로그래밍을 안 함?\n\n반응형 프로그래밍에서의 코드를 작성하고 유지하려면 더욱 비용이 커지고, 복잡해진다.\n\n\n  대부분 FP 스타일로 작성되어 처음엔 보기 쉽겠지만, subscribeOn과 같이 실행 흐름을 다른 스레드로 넘겨 버리는 함수가 존재해 실행 흐름을 판단하기 어려울 것이고, 다 다른 스레드에서 작동된다면 당연히 예외 추적도 힘들 것이다.\n\n\nSuspend 키워드?\n\nsuspend 키워드는 코루틴에서 빠지면 안되는 기능이다.\n\n해당 키워드를 메서드(함수)에 붙이게 된다면 해당 함수는 코루틴이라고 명시를 해줄 수 있고, 일시 중지를 할 수 있는 메서드라고 표시를 한다.\n\n⇒ 일시 중지하고 언젠간? 재시작\n\nsuspend fun minjuIsComing() {\n  logger.info(\"민주가 오고 있어요!\") // 함수 시작 point\n  delay(500L) // delay(timeMillis: Long) // 함수 중단 point\n  logger.info(\"민주가 도착했어요!\") // 함수 재개 point\n}\n\n\nminjuIsComing 코루틴이 실행될 때 delay 기능에서 일시 중지하고, 다시 재개를 한다.\n\n해당 메커니즘을 자세히 소개 해주겟다\n\nsuspending 된 함수는 전체 문맥(context)가 Continuation&lt;T&gt;에 저장된다. \nContinuation 객체에는 함수의 변수 및 매개변수의 모든 상태, 실행이 중단된 지점(label)이 저장이 된다.\n\n코틀린 컴파일러는 중지된 함수를 아래와 같이 재구성? 한다.\n\nsuspend fun minjuIsComing()\n\nfun minjuIsComing(continuation: Continuation&lt;*&gt;): Any \n\n\n? 컴파일러 녀석이 왜 변환 값까지 바꾸나요.\n\nsuspend함수가 일시 중지되면 함수 값을 반환할 수 없다.\n\n하지만, 함수가 일시 중지되었음을 표시하는 값(COROUTINE_SUSPENDED)을 반환해야하기 때문에 반환 값이 바뀌는 것이다.\n\n파라미터로 받는 continuation 객체에 해당 함수의 정보를 저장하기 위해 래핑을 한 번한다.\n\n래핑을 해 생긴 continuation 객체의 이름은 MinjuIsComingContinuation이다.\n\n\n  **정지 함수를 호출할 때마다 continuation 객체를 새 함수로 래핑을 한다.\n\n\n실행 정보를 저장하는 필드 label은 해당 함수가 처음 시작되면 0이고, 만약 0이라면 중단 함수를 만날 때까지 실행하다가 중단 함수(delay)를 만나 label은 1이 되고, 중단 함수를 실행 시키게 된다.\n\ndelay 함수가 COROUTINE_SUSPENDED를 반환하게 되면 해당 코루틴은 중지된 것으로 판단된다.\n\nDispatcher\n\ncoroutine에서 Thread에 코루틴을 전달하는 스케줄러 역할을 한다.\n\nStructured Concurrency\n\nCoroutine Scope\n\ncoroutineScope는 구조적 동시성을 구현한다.\n\n\n  상위 코루틴이 취소되면 하위 코루틴도 취소\n  하위 코루틴이 예외를 발생시키면 상위 코루틴도 중지\n\n\ncoroutineScope는 실행이 끝날 때까지 이전 코루틴의 실행을 일시 중단하는 새로운 코루틴을 생성한다.\n\nsuspend fun minjuRoutine() {\n    coroutineScope {\n        minjuIsComing()\n    }\n    coroutineScope {\n        minjuIsGoing()\n    }\n}\n\nsuspend fun minjuIsComing() {\n    log.info(\"민주가 오고 있어요!\")\n    delay(500L)\n    log.info(\"민주가 도착했어요!\")\n}\n\nsuspend fun minjuIsGoing() {\n    log.info(\"민주가 가고 있어요ㅜㅜ\")\n    delay(1000L)\n    log.info(\"민주가 가버렸어요ㅜㅜ\")\n}\n\n\n17:23:26.285 [main] INFO **MainLogger** - start\n17:23:26.378 [**main**] INFO Example - 민주가 오고 있어요!\n17:23:27.013 [kotlinx.coroutines.DefaultExecutor] INFO Example - 민주가 도착했어요!\n17:23:27.031 [kotlinx.coroutines.DefaultExecutor] INFO Example - 민주가 가고 있어요ㅜㅜ\n17:23:28.041 [kotlinx.coroutines.DefaultExecutor] INFO Example - 민주가 가버렸어요ㅜㅜ\n17:23:28.056 [kotlinx.coroutines.**DefaultExecutor**] INFO **MainLogger** - end\n\n\n실행은 순전히 순차적이다. 하지만 런타임은 두 개의 서로 다른 스레드를 사용해 전체 프로세스를 실행한다.\n\n코루틴에서 중단이 되었다 다시 재개할 때 중단 되었던 스레드에서 다시 시작한다는 보장이 없다.\n\n⇒ 재개할 시엔 다른 스레드에서 실행될 수 있다.\n\nCoroutine Builder\n\n코루틴을 생성할 수 있다.\n\nLaunch Builder\n\n특정 코드를 실행하지만, 그 결과값이 필요없을 때 사용된다.\n\nsuspend fun minjuRoutine() {\n    coroutineScope {\n        launch {\n            minjuIsComing()\n        }\n        launch {\n            minjuIsGoing()\n        }\n    }\n}\n\n\n18:44:54.289 [main] INFO MainLogger - start\n18:44:54.856 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!\n18:44:54.961 [DefaultDispatcher-worker-2] INFO Example - 민주가 가고 있어요ㅜㅜ\n18:44:55.554 [DefaultDispatcher-worker-2] INFO Example - 민주가 도착했어요!\n18:44:56.042 [DefaultDispatcher-worker-2] INFO Example - 민주가 가버렸어요ㅜㅜ\n18:44:56.043 [DefaultDispatcher-worker-2] INFO MainLogger - end\n\n\n위의 실행 결과 처럼 하나의 스코프 안에서 두 개의 코루틴을 동시에 실행한다. 두 개의 worker 스레드를 이용하여 처리한 것을 볼 수 있다.\n\n\n  두 코루틴은 동일한 범위의 하위 항목이므로 두 코루틴 모두 실행이 끝날 때까지 기다린 후 반환\n\n\nGlobalScope\n\nGlobalScope를 사용해 구조적 동시성 사용을 피할 수 있다.\n\nsuspend fun minjuRoutineGlobal() {\n    GlobalScope.launch {\n        minjuIsComing()\n    }\n    GlobalScope.launch {\n        minjuIsGoing()\n    }\n    Thread.sleep(1500L)\n}\n\n\n18:56:07.017 [main] INFO MainLogger - start\n18:56:07.409 [DefaultDispatcher-worker-1] INFO Example - 민주가 가고 있어요ㅜㅜ\n18:56:07.409 [DefaultDispatcher-worker-3] INFO Example - 민주가 오고 있어요!\n18:56:07.947 [DefaultDispatcher-worker-1] INFO Example - 민주가 도착했어요!\n18:56:08.448 [DefaultDispatcher-worker-1] INFO Example - 민주가 가버렸어요ㅜㅜ\n18:56:08.908 [main] INFO MainLogger - end\n\n\n하지만, 이 경우엔 코루틴 실행이 끝날 때까지 약간의 대기 시간을 추가 해야한다.\n(delay(1500L) 또는Thread.sleep(1500L)..)\n\n\n  부모-자식 관계를 강제하지 않는 빈 코루틴 범위와 같다.\n\n\nJob\n\nlaunch 함수를 사용하면 Job을 반환한다.\n\n\n  Job은 코루틴에 대한 핸들러이다.\n  이를 사용하여 코루틴 실행을 취소하거나 완료될 때까지 기다릴 수 있다.\n\n\nsuspend fun minjuRoutineJob() {\n    coroutineScope {\n        val minjuIsComingJob: Job = launch {\n            minjuIsComing()\n        }\n        val  minjuIsGoingJob: Job = launch {\n             minjuIsGoing()\n        }\n        minjuIsComingJob.join()\n        minjuIsGoingJob.join()\n        launch {\n            minjuStartAndEnd()\n        }\n    }\n}\n\n\n19:07:23.041 [main] INFO MainLogger - start\n19:07:23.530 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!\n19:07:23.548 [DefaultDispatcher-worker-2] INFO Example - 민주가 가고 있어요ㅜㅜ\n19:07:24.145 [DefaultDispatcher-worker-1] INFO Example - 민주가 도착했어요!\n19:07:24.627 [DefaultDispatcher-worker-1] INFO Example - 민주가 가버렸어요ㅜㅜ\n19:07:24.648 [DefaultDispatcher-worker-2] INFO Example - 민주가 시작했어요!\n19:07:25.163 [DefaultDispatcher-worker-2] INFO Example - 민주가 끝났어요!\n19:07:25.164 [DefaultDispatcher-worker-2] INFO MainLogger - end\n\n\n스코프 내의 3개의 코루틴이 동시에 실행될 것 같지만 아니다.\n\n로그를 확인해 보면 minjuStartAndEnd는 나머지 두 개의 코루틴이 끝나고서야 실행되는 것을 확인할 수 있다.\n\n이것이 구조적 동시성이다.\n\n위의 코드에선 Job 객체를 통해 Join을 해주어 구조적 동시성을 달성했지만, 우리는 코드를 어떻게 바꿔야할 지 알고 있다\n\nsuspend fun minjuRoutineJob() {\n    coroutineScope {\n        coroutineScope {\n            launch {\n                minjuIsComing()\n            }\n            launch {\n                minjuIsGoing()\n            }\n        }\n        launch {\n            minjuStartAndEnd()\n        }\n    }\n}\n\n\n19:14:55.673 [main] INFO MainLogger - start\n19:14:55.854 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!\n19:14:55.861 [DefaultDispatcher-worker-2] INFO Example - 민주가 가고 있어요ㅜㅜ\n19:14:56.412 [DefaultDispatcher-worker-2] INFO Example - 민주가 도착했어요!\n19:14:56.906 [DefaultDispatcher-worker-2] INFO Example - 민주가 가버렸어요ㅜㅜ\n19:14:56.911 [DefaultDispatcher-worker-2] INFO Example - 민주가 시작했어요!\n19:14:57.413 [DefaultDispatcher-worker-2] INFO Example - 민주가 끝났어요!\n19:14:57.413 [DefaultDispatcher-worker-2] INFO MainLogger - end\n\n\ncoroutineScope를 사용해 같은 결과를 얻을 수 있다.\n\nAsync Builder\n\n코루틴 실행에서 결과 값을 반환해야할 때 사용한다.\n\nsuspend fun minju(): String {\n    log.info(\"민주 생성 중~~\")\n    delay(500L)\n    log.info(\"생성 완료!\")\n    return \"민주\"\n}\n\nsuspend fun findMinju(): Int {\n    log.info(\"민주 찾는 중~~\")\n    delay(1000L)\n    log.info(\"찾았습니다!\")\n    return 511\n}\n\nsuspend fun minjuRoutineAsync() {\n    coroutineScope {\n        val minju: Deferred&lt;String&gt; = async {\n            minju()\n        }\n        val findMinju: Deferred&lt;Int&gt; = async {\n            findMinju()\n        }\n        log.info(\"${minju.await()}를 ${findMinju.await()}일 만에 찾았습니다!\")\n    }\n}\n\n\n20:30:35.294 [main] INFO MainLogger - start\n20:30:35.459 [DefaultDispatcher-worker-1] INFO Example - 민주 생성 중~~\n20:30:35.476 [DefaultDispatcher-worker-2] INFO Example - 민주 찾는 중~~\n20:30:36.004 [DefaultDispatcher-worker-1] INFO Example - 생성 완료!\n20:30:36.499 [DefaultDispatcher-worker-1] INFO Example - 찾았습니다!\n20:30:36.501 [DefaultDispatcher-worker-1] INFO Example - 민주를 511일 만에 찾았습니다!\n20:30:36.501 [DefaultDispatcher-worker-1] INFO MainLogger - end\n\n\nDeferred 변수에 async 실행 결과를 저장하고, await을 통해 값을 가져온다.(기다린다)\n\nCancellation\n\n코루틴 실행을 취소해보자\n\nsuspend fun cancelMinjuRoutine() {\n    coroutineScope { \n        val minjuJob: Job = launch {\n            minjuIsComing()\n        }\n        launch {\n            delay(400L)\n            minjuJob.cancel()\n            minjuJob.join()\n            log.info(\"민주가 사라졌어요..\")\n        }\n    }\n}\n\n\n16:49:58.741 [main] INFO MainLogger - start\n16:49:59.027 [DefaultDispatcher-worker-1] INFO Example - 민주가 오고 있어요!\n16:49:59.483 [DefaultDispatcher-worker-1] INFO Example - 민주가 사라졌어요..\n16:49:59.484 [DefaultDispatcher-worker-1] INFO MainLogger - end\n\n\n민주가 오다가 사라져버린다.. 이 얼마나 안타까운 일인가;;\n\nJob 또는 Deferred 클래스에서 cancel 함수를 구현해 코루틴을 취소할 수 있다.\n\n하지만 코루틴의 실행을 취소 시키려면 일시 중지(delay)가 무조건 필요하다.\n\n단순히 cancel만 사용하게 된다면, 해당 코루틴은 즉시 중지되지 않고, 계속 실행될 수 있다.\n\n\n  cancel 함수는 취소 중이라는 상태를 나타낸다.\n\n\n이런 실행 취소 신호(CancellationException)를 보내 감지를 해야하는데, 일시 중지 상태에서 해당 코루틴이 취소된 것을 알 수 있다.\n\ncancel-join은 일반적인 패턴이라 Job.cancelAndJoin()을 통해 결합된 함수를 사용할 수 있다.\n\n코루틴의 취소는 하위 코루틴까지 전파가 된다(코드는 따로 안 줄거임)\n\n⇒ 코루틴을 취소하면 모든 자식이 암시적으로 취소가 됌\n\nCoroutine Context\n\n상위 코루틴으로부터 하위 코루틴에게 전달된 정보를 저장하여 내부적으로 구조적 동시성을 달성하는 방법\n\n\n  CoroutineScope는 Coroutine context 참조를 유지한다.\n\n\n⇒ 자식까지 전염된다.\n\nsuspend fun minjuRoutineContext() {\n    coroutineScope {\n        launch(CoroutineName(\"아일릿-민주\") + Dispatchers.Default) {\n            log.info(\"Hello, Minju!\")\n        }\n    }\n}\n\n\n17:05:15.688 [DefaultDispatcher-worker-1 @**아일릿-민주**#1] INFO Example - Hello, Minju!\n\n\n해당 로그에서 코루틴이 지정된 이름으로 생성되고, 실행되는 것을 확인할 수 있다.\n\nsuspend fun minjuRoutineContext() {\n    coroutineScope {\n        launch(CoroutineName(\"아일릿-민주\") + Dispatchers.Default) {\n            log.info(\"Hello, Minju!\")\n            launch {\n                log.info(\"Lovely Minju!\")\n            }\n        }\n    }\n}\n\n\n17:09:45.482 [main] INFO MainLogger - start\n17:09:45.699 [DefaultDispatcher-worker-1 **@아일릿-민주#1**] INFO Example - Hello, Minju!\n17:09:45.711 [DefaultDispatcher-worker-2 **@아일릿-민주#2**] INFO Example - Lovely Minju!\n17:09:45.712 [DefaultDispatcher-worker-2 **@아일릿-민주#2**] INFO MainLogger - end\n\n\n하위 코루틴까지 Context Name이 전염(전달)되는 것을 확인할 수 있다.\n"
    },
  
    {
      "title": "Scoped Values",
      "url": "/blog/language/scoped-values/",
      "date": "2024년 05월 26일",
      "categories": ["language"],
      "tags": ["Java","Java 21","Scoped Values"],
      "content": "특정 스레드 또는 작업으로 제한되는 범위 값을 생성할 수 있는 기능이다.\n\n스레드 로컬 변수와 비슷하지만, \n이 범위 값은 virtual threads, structured concurrency와 함께 작동되도록 설계되었다.\n\n복잡한 동기화나 잠금 메커니즘 없이 구조화된 방식으로 작업과 가상 스레드 간에 값을 전달 가능하고,\n\n스레드 로컬 변수와 달리 범위 값은 한 번 작성되며 스레드 실행 중 제한된 기간 동안만 사용할 수 있다\nScopedValue&lt;&gt;\n"
    },
  
    {
      "title": "Reference Type",
      "url": "/blog/language/reference-type/",
      "date": "2024년 05월 26일",
      "categories": ["language"],
      "tags": ["Java","Reference Type"],
      "content": "프로그램이 객체 생명 주기를 효과적으로 관리할 수 있는 객체 참조 유형 4가지를 정리합니다\n\nStrong\n\n강한 참조 타입. 가장 일반적으로 사용되는 참조 타입이다.\n\n\n  해당 Strong 참조가 있는 객체는 GC의 대상이 되지 않는다.\n\n\nObject strongReference = new Object();\n\n\n메모리 공간이 부족하다 해도, 회수를 하지 않는다.\n\nGC의 대상이 되게 하려면\n\n\n  참조 X\n\n\npublic void test() {\n    Object strongReference = new Object();\n}\n\n\n해당 메서드 블록이 실행되고 메서드 스택이 종료된다면, 참조된 객체가 0이므로 해당 객체는 재활용될 것이다.\n\n하지만 이 내용은 지역 변수에만 해당하는 내용이라 인스턴스 변수의 Strong 참조일 경우 GC의 대상이 되게하려면 strongReference객체를 null로 설정하는 방법이 있다.\n\nSoft\n\n소프트 참조만 있는 경우 GC는 메모리 공간이 충분할 때엔 해당 객체를 회수하지 않는다.\n\n// Strong reference\nString strongReference = new String(\"abc\");\n// Soft references\nString str = new String(\"abc\");\nSoftReference&lt;String&gt; softReference = new SoftReference&lt;String&gt;(str);\n\n\nJVM 메모리가 부족할 때 소프트 참조 개체는 회수된다.\n\n메모리가 부족하면 JVM은 먼저 해당 객체 참조를 null로 설정 후 GC의 대상이 되도록 한다.\n\n탐색한 웹 페이지를 찾거나 뒤로 가기를 할 때 사용될 수 있다.\n\nWeak\n\n약한 참조만 있는 객체가 발견되면 현재 메모리 공간이 충분한지 여부에 관계없이 해당 객체의 메모리가 회수한다.\n\n하지만, GC는 스레드 우선순위가 낮아 해당 객체를 빨리 찾지 못할 수 있다.\n\nString str = new String(\"abc\");\nWeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);\n\n\nString str = new String(\"abc\");\nWeakReference&lt;String&gt; weakReference = new WeakReference&lt;&gt;(str);\nString strongReference = weakReference.get();\n\n\n위와 같이 약한 객체를 강한 객체로 변경할 수 있다.\n\nPhantom\n\n쓸모가 없다.\n\n해당 참조는 객체의 생명 주기를 결정하지 않는다.\n\n→ GC가 해당 객체를 보기에 참조가 없는 것 처럼 보인다.\n"
    },
  
    {
      "title": "ForkJoinPool",
      "url": "/blog/language/forkjoinpool/",
      "date": "2024년 04월 30일",
      "categories": ["language"],
      "tags": ["Java","ForkJoinPool","Parallelism"],
      "content": "ForkJoinPool이란?\nFork/Join 프레임워크 기반으로 작업을 병렬로 실행하고 작업을 더 작은 하위 작업으로 나누고, 최종 결과로 결합하는 ForkJoinTask를 위한 스레드 풀이다. (ExecutorService 구현)\n\nWork stealing algo\n\n작업을 마친 작업자 스레드가 다른 스레드에서 보류 중인 작업을 훔칠 수 있는 전략\n\n\n  병렬 실행에서는 작업이 여러 프로세서/코어로 나누어지는데 idle 상태가 되면 오버헤드 발생으로 다른 프로세서의 오버로드된 대기열(작업 대기열)에서 작업을 할당 받아야한다.\n\n\nFork/Join\n\nFork\n\n작업을 분할/분해\n\n\n  작업을 스레드 풀의 작업 큐에 넣는다.\n  비동기 메서드\n\n\nJoin\n\n풀 작업의 결과를 결합\n\n\n  동기 메서드\n\n\n예제\n\npublic class Main {\n    public static void main(String[] args) {\n        long[] numbers = new long[1_000_000];\n        for (int i = 0; i &lt; numbers.length; i++) {\n            numbers[i] = i;\n        }\n\n        ForkJoinPool pool = new ForkJoinPool();\n        Task task = new Task(numbers, 0, numbers.length);\n        long result = pool.invoke(task);\n        System.out.println(\"Sum: \" + result);\n\n        pool.shutdown();\n    }\n}\n\n\npublic class Task extends RecursiveTask&lt;Long&gt; {\n    private final long[] numbers;\n    private int start;\n    private int end;\n\n    public Task(long[] numbers, int start, int end) {\n        this.numbers = numbers;\n        this.start = start;\n        this.end = end;\n    }\n\n    @Override\n    protected Long compute() {\n        int length = end - start;\n\n        if (length &lt;= 100) {\n            long sum = 0;\n\n            for (int i = start; i &lt; end; i++) {\n                sum += numbers[i];\n            }\n            return sum;\n        }\n        int middle = start + length / 2;\n        Task leftTask = new Task(numbers, start, middle);\n        Task rightTask = new Task(numbers, middle, end);\n\n        leftTask.**fork**();\n        Long rightResult = rightTask.compute();\n        Long leftResult = leftTask.**join**();\n\n        return leftResult + rightResult;\n    }\n}\n\n"
    }
  
]
